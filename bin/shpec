#!/usr/bin/env bash

usage () {
  cat <<EOF
Shellspec

Usage:
  $ ${0##*/} [options] [filename ...]

Options:
  -h, --help     Print this message
  -v, --version  Print version number

EOF
}

indent () {
  printf '%*s' $(( (_shpec_indent - 1) * 2))
}

section () {
  printf "%b\n" "$*";
}

log () {
  indent && section "$@"
}

sanitize () {
  IFS= section "$1" | tr '\n' 'n' | tr "'" 'q'
}

describe () {
  : $((_shpec_indent += 1))
  log "$1"
}

run () {
  output="$($@)"
  status="$?"
}

end () {
  : $((_shpec_indent -= 1))
  _shpec_assertion_printed=0

  if [ $_shpec_indent -ge 0 ]; then
    return 0
  fi

  echo "shpec: $_shpec_file: unexpected 'end'" >&2
  exit 1
}

stub_command () {
  _shpec_stub_body="${2:-:}"
  eval "$1() { ${_shpec_stub_body}; }"
}

unstub_command () {
  unset -f "$1";
}

it () {
  : $((_shpec_indent += 1))
  : $((_shpec_examples += 1))
  _shpec_assertion="$1"
}

is_function () {
  case $(LC_ALL=C type "$1" 2> /dev/null) in
    *function*) return 0;;
    *) return 1 ;;
  esac
}

assert () {
  case "x${1:-}" in
    xequal)
      print_result "[ '$(sanitize "$2")' = '$(sanitize "$3")' ]" \
        "Expected [$2] to equal [$3]"
      ;;
    xunequal)
      print_result "[ '$(sanitize "$2")' != '$(sanitize "$3")' ]" \
        "Expected [$2] not to equal [$3]"
      ;;
    xgt)
      print_result "[ $2 -gt $3 ]" \
        "Expected [$2] to be > [$3]"
      ;;
    xlt)
      print_result "[ $2 -lt $3 ]" \
        "Expected [$2] to be < [$3]"
      ;;
    xcontain)
      if [[ "$2" == *"$3"* ]]; then
        result
      else
        result "Expected [$2] contain [$3]"
      fi
      ;;
    xglob)
      print_result "case '$2' in $3) :;; *) false;; esac" \
        "Expected [$2] to match [$3]"
      ;;
    xno_glob)
      print_result "case '$2' in $3) false ;; *) :;; esac" \
        "Expected [$2] not to match [$3]"
      ;;
    xpresent)
      print_result "[ -n '$2' ]" \
        "Expected [$2] to be present"
      ;;
    xblank)
      print_result "[ -z '$2' ]" \
        "Expected [$2] to be blank"
      ;;
    xfile_present)
      print_result "[ -e $2 ]" \
        "Expected file [$2] to exist"
      ;;
    xfile_absent)
      print_result "[ ! -e $2 ]" \
        "Expected file [$2] not to exist"
      ;;
    xsymlink)
      link="$(readlink "$2")"
      print_result "[ '$link' = '$3' ]" \
        "Expected [$2] to link to [$3], but got [$link]"
      ;;
    xtest)
      print_result "$2" \
        "Expected $2 to be true"
      ;;
    xgrep)
      print_result "echo \"$2\" | grep -q \"$3\"" "Expected [$2] to match [$3]"
      ;;
    xno_grep)
      print_result "echo \"$2\" | grep -qv \"$3\"" "Expected [$2] to not match [$3]"
      ;;
    xegrep )
      print_result "echo \"$2\" | egrep -q \"$3\"" "Expected [$2] to match [$3]"
      ;;
    xno_egrep)
      print_result "echo \"$2\" | egrep -qv \"$3\"" "Expected [$2] to not match [$3]"
      ;;
    *)
      if is_function "${1:-}"; then
        _shpec_matcher="${1:-}"
        shift
        $_shpec_matcher "$@"
        return 0
      else
        print_result false "Error: Unknown matcher [$1]"
      fi
      ;;
  esac
}

result () {
  if [ "${1:-0}" = 0 ]; then
    ((_shpec_assertion_printed++))

    if [ "$_shpec_assertion_printed" -le 1 ]; then
      log "$_shpec_green$_shpec_assertion$_shpec_norm"
      return 0
    fi

    printf "%b" "$_shpec_clear_ln"
    log "$_shpec_green$_shpec_assertion$_shpec_norm(x$_shpec_assertion_printed)"
    return 0
  fi

  ((_shpec_failures += 1))
  _shpec_assertion_printed=0

  log "$_shpec_red$_shpec_assertion"
  log "($1)$_shpec_norm"
}

print_result () {
  if eval "$1"; then
    : $((_shpec_assertion_printed += 1))
    if [ ${_shpec_assertion_printed} -le 1 ]; then
      log "$_shpec_green$_shpec_assertion$_shpec_norm"
    else
      printf "%b" "$_shpec_clear_ln"
      log "$_shpec_green$_shpec_assertion$_shpec_norm(x$_shpec_assertion_printed)"
    fi
  else
    : $((_shpec_failures += 1))
    _shpec_assertion_printed=0
    log "$_shpec_red$_shpec_assertion"
    log "($2)$_shpec_norm"
  fi
}

final_results () {
  local color status

  if [ "$_shpec_failures" -eq 0 ]; then
    color=$_shpec_green
    status=0
  else
    color=$_shpec_red
    status=1
  fi

  section "${color}${_shpec_examples} examples, ${_shpec_failures} failures${_shpec_norm}"
  times
  exit "$status"
}

shpec () {
  (
    _shpec_examples=0
    _shpec_failures=0
    _shpec_indent=0
    _shpec_red="\033[0;31m"
    _shpec_green="\033[0;32m"
    _shpec_norm="\033[0m"
    _shpec_clear_ln="\033[1A\033[K"
    _shpec_matcher_files=""

    if [ "${SHPEC_ROOT:-}" ]; then
      _shpec_root="$SHPEC_ROOT"
    elif [ -d "./shpec" ]; then
      _shpec_root="./shpec"
    else
      _shpec_root="."
    fi

    SHPEC_ROOT="$_shpec_root"

    if [ -d "$_shpec_root/matchers" ]; then
      _shpec_matcher_files="$(find "$_shpec_root/matchers" -name '*.sh' 2>/dev/null)"
    fi

    for _shpec_matcher_file in $_shpec_matcher_files; do
      . "$_shpec_matcher_file"
    done

    if [ $# -eq 0 ]; then
      _shpec_files="$(find "$_shpec_root" -name '*_shpec.*')"
    else
      _shpec_files="${*}"
    fi

    for _shpec_file in $_shpec_files; do
      . "$_shpec_file"
    done

    final_results
  )
}

(
  case "${1:-}" in
    -v|--version) echo "0.0.0"; exit 0 ;;
    -h|--help) usage; exit 0 ;;
  esac

  _progname="shpec"
  _pathname="$(command -v "$0")"
  _cmdname="${_pathname##*/}"
  _main="shpec"

  case $_progname in
    "${_cmdname%.sh}") $_main "$@";;
  esac
)
