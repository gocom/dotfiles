#!/usr/bin/env bash

app_name="${0##*/}"
app_version="0.0.0"

usage () {
  cat <<EOF
Interactively cherry-picks commits by searching their messages for a keyword.

This tool is intended for tasks where set of commits need to be taken
to a target branch in their original commit date order. This could, for
instance, be used to build release branches from a main branch.

Usage:
  $ $app_name [options] <source-branch> <keyword ...>

Options:
  -h, --help      Print this message
  -v, --version   Print version number
  -D, --dry-run   Dry-run without writing
  -S, --silent    Silent mode
  -V, --verbose   Verbose output
      --color     Enable colors
      --no-color  Disable colors

      --all       Select all matching commits

Examples:
  $ git checkout release/2022-01
  $ $app_name main EXAMPLE-101

EOF
}

main () {
  local args OPTIND OPTARG OPTERR option \
    color dryrun silent verbose all \
    reset red green yellow blue magenta cyan

  args=()

  for option in "$@"; do
    case "$option" in
      -*) break ;;
      *) args+=("$option"); shift ;;
    esac
  done

  color="always"

  if [ "${TERM:-}" = "dumb" ] || [ "${NO_COLOR:-}" ]; then
    color=""
  fi

  while getopts ":hvVDQS-:" option; do
    case "$option" in
      -)
        case "$OPTARG" in
          help) usage; exit 0 ;;
          version) echo "$app_version"; exit 0 ;;
          color) color="always" ;;
          dryrun|dry-run) dryrun=1 ;;
          no-color) color="" ;;
          verbose) verbose=1 ;;
          quiet|silent) silent=1 ;;
          all) all=1 ;;
          *) fatal "Invalid option: --$OPTARG" ;;
        esac
        ;;
      h) usage; exit 0 ;;
      v) echo "$app_version"; exit 0 ;;
      D) dryrun=1 ;;
      Q|S) silent=1 ;;
      V) verbose=1 ;;
      \?) fatal "Invalid option: -$OPTARG" ;;
      :) fatal "Option -$OPTARG requires an argument." ;;
      *) fatal "Unexpected: -$OPTARG" ;;
    esac
  done

  shift "$((OPTIND - 1))"
  set -- "${args[@]}"

  if [ "$color" ]; then
    reset="$(tput sgr0)"
    red="$(tput setaf 1)"
    green="$(tput setaf 2)"
    yellow="$(tput setaf 3)"
    blue="$(tput setaf 4)"
    magenta="$(tput setaf 5)"
    cyan="$(tput setaf 6)"
  fi

  pick "$@"
}

msg () {
  local message

  for message in "$@"; do
    echo "$message"
  done
}

log () {
  if ! [ "$silent" ]; then
    msg "$@"
  fi
}

err () {
  log "$@" >&2
}

fatal () {
  err "$@"
  exit 1
}

pick() {
  local branch selected selection hash

  if [ "$#" -eq 0 ]; then
    fatal "${red}✘${reset} Branch is required."
  fi

  if [ "$dryrun" ]; then
    log "${blue}ℹ${reset} Running with ${yellow}--dry-run${reset}, nothing will be written."
  fi

  branch="${1:-}"

  shift 1

  # shellcheck disable=SC2046
  set -- $(hashes "$@")

  if [ "$#" -eq 0 ]; then
    fatal "${cyan}·${reset} No commits found matching the given criteria."
  fi

  commits "$@"

  if [ "$all" ] || [ "$silent" ]; then
    selected="all"
  else
    read -r -p "Cherry-pick commit row (1-n, all, exit): " selected
  fi

  case "$selected" in
    e*|E*|"") exit 0 ;;
    *) selection "$selected" "$@" ;;
  esac

  for hash in "${selection[@]}"; do
    cherry-pick "$hash"
  done

  log "${green}✓${reset} All selected commits processed"
}

commits() {
  local hash index

  index=1

  for hash in "$@"; do
    commit "$hash" "$index" "${##}"
    ((index++))
  done
}

commit () {
  local index paddingLength padding width spacing pretty

  if [ "$silent" ]; then
    return 0
  fi

  index="${2:-}"
  paddingLength="${3:-0}"

  padding="    "
  padding="${padding:1:$paddingLength}"
  spacing="${#padding}"

  ((width=80-2-spacing))

  pretty="$(printf '%s  %s  %s  %s  %s' \
    "${padding:${#index}}%C(auto,green)$index%Creset"\
    "%<($width,trunc)%s%n$padding"\
    "%C(auto,yellow)%h%Creset"\
    "%C(auto,magenta)%ad%Creset"\
    "%<(40,trunc)%an")"

  git show \
    --reverse \
    --quiet \
    --color="${color:-never}" \
    --date=format:'%Y-%m-%d %H:%M:%S' \
    --pretty="${pretty[*]}" \
    "$1"
}

selection () {
  local min max row i hash

  selection=()

  row="$1"

  shift 1

  case "$row" in
    a*|"") ;;
    *-*)
      min="$(echo "$row" | awk -F '-' '{print $1}')"
      max="$(echo "$row" | awk -F '-' '{print $2}')"
      ;;
    *)
      min="$row"
      max="$row"
      ;;
  esac

  min="${min:-1}"
  max="${max:-$#}"

  if ! [[ "$min" =~ ^[0-9]+$ ]] || [ "$min" -lt 1 ]; then
    fatal "${red}✘${reset} Invalid minimum selection range '$min'"
  fi

  if ! [[ "$max" =~ ^[0-9]+$ ]] || [ "$max" -gt "$#" ]; then
    fatal "${red}✘${reset} Invalid maximum selection range '$max'"
  fi

  for ((i=min;i<=max;i++)); do
    hash="${*:$i:1}"

    if ! [ "$hash" ]; then
      fatal "${red}✘${reset} Invalid row number '$i'"
    fi

    selection+=("$hash")
  done

  return 0
}

cherry-pick () {
  local abort hash

  hash="${1:-}"

  log "${magenta}↯${reset} Cherry-picking ${yellow}$hash${reset}"

  if [ "$verbose" ]; then
    commit "$hash"
  fi

  run cherry-pick -x "$hash" && return 0

  err "${red}✘${reset} Cherry-picking ${yellow}$hash${reset} failed"

  read -r -p "Skip and continue from the next commit (Yes/no)? " abort

  case "$abort" in
    Y*|y*)
      run cherry-pick --abort \
        || fatal "${red}✘${reset} Aborting cherry-pick failed"
        ;;
    *)
      fatal "${red}✘${reset} Exiting and leaving cherry-pick in progress"
      ;;
  esac
}

run () {
  if [ "$dryrun" ]; then
    return 0
  fi

  if [ "$silent" ]; then
    git "$@" > /dev/null 2>&1
  elif [ "$verbose" ]; then
    git "$@"
  else
    git "$@" > /dev/null
  fi

  return "$?"
}

hashes () {
  local args option

  args=()

  for option in "$@"; do
    args+=("--grep=$option")
  done

  git --no-pager log --pretty=tformat:"%H" "${args[@]}" "$branch"
}

main "$@"
